// Code generated by command: avogen -output zmov.go mov. DO NOT EDIT.

package build

import (
	"github.com/mmcloughlin/avo/operand"
	"go/types"
)

func (c *Context) mov(a, b operand.Op, an, bn int, t *types.Basic) {
	switch {
	case an == 1 && bn == 1 && (t.Info()&types.IsInteger) != 0:
		c.MOVB(a, b)
	case an == 1 && bn == 4 && (t.Info()&types.IsInteger) != 0 && (t.Info()&types.IsUnsigned) == 0:
		c.MOVBLSX(a, b)
	case an == 1 && bn == 4 && (t.Info()&types.IsInteger) != 0 && (t.Info()&types.IsUnsigned) != 0:
		c.MOVBLZX(a, b)
	case an == 1 && bn == 8 && (t.Info()&types.IsInteger) != 0 && (t.Info()&types.IsUnsigned) == 0:
		c.MOVBQSX(a, b)
	case an == 1 && bn == 8 && (t.Info()&types.IsInteger) != 0 && (t.Info()&types.IsUnsigned) != 0:
		c.MOVBQZX(a, b)
	case an == 1 && bn == 2 && (t.Info()&types.IsInteger) != 0 && (t.Info()&types.IsUnsigned) == 0:
		c.MOVBWSX(a, b)
	case an == 1 && bn == 2 && (t.Info()&types.IsInteger) != 0 && (t.Info()&types.IsUnsigned) != 0:
		c.MOVBWZX(a, b)
	case an == 4 && bn == 4 && (t.Info()&types.IsInteger) != 0:
		c.MOVL(a, b)
	case an == 4 && bn == 8 && (t.Info()&types.IsInteger) != 0 && (t.Info()&types.IsUnsigned) == 0:
		c.MOVLQSX(a, b)
	case an == 4 && bn == 8 && (t.Info()&types.IsInteger) != 0 && (t.Info()&types.IsUnsigned) != 0:
		c.MOVLQZX(a, b)
	case an == 16 && bn == 16 && (t.Info()&types.IsInteger) != 0:
		c.MOVOU(a, b)
	case an == 16 && bn == 8 && (t.Info()&types.IsInteger) != 0:
		c.MOVQ(a, b)
	case an == 8 && bn == 16 && (t.Info()&types.IsInteger) != 0:
		c.MOVQ(a, b)
	case an == 16 && bn == 16 && (t.Info()&types.IsInteger) != 0:
		c.MOVQ(a, b)
	case an == 8 && bn == 8 && (t.Info()&types.IsInteger) != 0:
		c.MOVQ(a, b)
	case an == 16 && bn == 8 && (t.Info()&types.IsFloat) != 0:
		c.MOVSD(a, b)
	case an == 16 && bn == 16 && (t.Info()&types.IsFloat) != 0:
		c.MOVSD(a, b)
	case an == 8 && bn == 16 && (t.Info()&types.IsFloat) != 0:
		c.MOVSD(a, b)
	case an == 16 && bn == 16 && (t.Info()&types.IsFloat) != 0:
		c.MOVSS(a, b)
	case an == 4 && bn == 16 && (t.Info()&types.IsFloat) != 0:
		c.MOVSS(a, b)
	case an == 16 && bn == 4 && (t.Info()&types.IsFloat) != 0:
		c.MOVSS(a, b)
	case an == 2 && bn == 2 && (t.Info()&types.IsInteger) != 0:
		c.MOVW(a, b)
	case an == 2 && bn == 4 && (t.Info()&types.IsInteger) != 0 && (t.Info()&types.IsUnsigned) == 0:
		c.MOVWLSX(a, b)
	case an == 2 && bn == 4 && (t.Info()&types.IsInteger) != 0 && (t.Info()&types.IsUnsigned) != 0:
		c.MOVWLZX(a, b)
	case an == 2 && bn == 8 && (t.Info()&types.IsInteger) != 0 && (t.Info()&types.IsUnsigned) == 0:
		c.MOVWQSX(a, b)
	case an == 2 && bn == 8 && (t.Info()&types.IsInteger) != 0 && (t.Info()&types.IsUnsigned) != 0:
		c.MOVWQZX(a, b)
	default:
		c.AddErrorMessage("could not deduce mov instruction")
	}
}
